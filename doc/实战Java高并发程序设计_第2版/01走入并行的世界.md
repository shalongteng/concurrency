#1、何去何从的并行计算
    1、忘掉那该死的并行
        linus观点：
            并行计算只能在图像处理和服务端编程两个领域使用，并且它在这两个领域确实有着广泛的使用
            但是在其他任何地方，并行计算毫无建树！
            
            并行使得程序更加复杂。
            
            图像处理
                多核并行计算
            服务端编程
                并行是业务上需要并行。世界本质是并行的。
    2、cpu瓶颈
        摩尔定律失效，CPU 主频的提升己经明显遇到了一些暂时不可逾越的瓶颈。
        
    3、柳暗花明：不断地前进
        2005 年开始，我们己经不再追求单核的计算速度，而是研究如何将多个独立的计算单元整合到单独的 CPU中，
        也就是我们所说的多核 CPU 。
    4、光明或是黑暗
        摩尔定律本应该由硬件开发人员维持，很不幸，硬件工程师似乎己经无计可施了 。为了继续保持性能的高速发展，
        硬件工程师想出了将CPU 内核塞进 CPU 里的想法。并行计算就被非常自然地推广开来。 带来软件设计的复杂性。
        因此，也就有了唐纳德的“他们将摩尔定律失效的责任推给了软件开发者”的说法
#2、有关并发的几个概念
    1、并发 Concurrency 和并行 Parallelism
        并发
            井发偏重于多个任务交替执行，而多个任务之间有可能还是串行的，
        并行
            而并行是真正意义上的“同时执行”
    2、临界区
        临界区用来表示一种公共资源或者说共享数据 ，可以被多个线程使用每一次，只能有一个线程使用它，
        临界区资源被占用，其他线程要想使用这个资源就必须等待。
    3、阻塞和非阻塞
        阻塞
            一个线程占用了临界区界区资源，其他所有需要这个资源的线程就必须等待，等待会导致线程挂起，这种情况就是阻塞。
        非阻塞
            非阻塞与之相反
    4、死锁（Deadlock）、饥饿（Starvation）和活锁（Livelock)
        死锁
            每个进程都在等待被其他进程占用并堵塞了的资源。例如，如果进程A锁住了记录1并等待记录2，
            而进程B锁住了记录2并等待记录1，这样两个进程就发生了死锁现象。
        饥饿
            一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如它的线程优先级可能太低，
            而高优先级的线程不断抢占它需要的资源，导致低优先级线程无法工作 。 
        活锁  （类似于算法不合理，死循环了）
            活锁是一系列进程在轮询地等待某个不可能为真的条件为真。活锁的时候进程是不会blocked，会导致耗尽CPU资源
            
            单一实体的活锁
                线程从队列中拿出一个任务来执行，如果任务执行失败，那么将任务重新加入队列，继续执行。
                假设任务总是执行失败，或者某种依赖的条件总是不满足，那么线程一直在繁忙却没有任何结果。
            协同导致的活锁
                生活中的典型例子： 两个人在窄路相遇，同时向一个方向避让，然后又向另一个方向避让，如此反复。
                通信中也有类似的例子，多个用户共享信道（最简单的例子是大家都用对讲机），同一时刻只能有一方发送信息。
                发送信号的用户会进行冲突检测， 如果发生冲突，就选择避让，然后再发送。 假设避让算法不合理，
                就导致每次发送，都冲突，避让后再发送，还是冲突。
                
                计算机中的例子：
                    两个线程发生了某些条件的碰撞后重新执行，那么如果再次尝试后依然发生了碰撞，长此下去就有可能发生活锁。
    5、并发的程度
        http://ifeve.com/why-is-wait-free-so-important/#more-10350
        
        1、阻塞(Blocking)
            synchronized关键字，或者重入锁时就会产生阻塞的线程
        
        2、无饥饿(Starvation-Free)
            低优先级线程产生饥饿
        
        3、无障碍(Obstruction-Free)
            这是一种最弱的非阻塞调度。两个线程如果都是无障碍执行，临界区被占用时，不会被阻塞。
            如果发现数据异常，就会对之前的操作进行回滚，确保数据安全。如果没有发生数据竞争，则可以顺利经过临界区。
        
        4、无锁(Lock-Free)
            一个无锁算法有一个方法，这个方法需要同步。在单线程模式下这个方法调用需要10ns，
            每增加一个线程调用这个方法，将在同步(变量)上产生争用。如果只有一个线程，每次调用该方法到返回时间都为10ns，
            如果你增加更多的线程，他们将会增加其他线程执行完成的时间，这是因为同一时刻只有一个线程能获得锁；
            
            记住，无锁(Lock-Free)保证一个线程可以执行，但没说是哪一个，并且在当前这个特定的例子中，
            每次只有一个线程可以执行(完成任务)，其他线程不得不从头开始：
        
        5、无等待(Wait-Free)
            所谓wait-free是指，不管其他线程执行什么操作，线程无论有什么操作都能在有限的步骤里面完成。
            所以对于算法来说达到lock-free不一定能达到wait-free，但是达到wait-free的算法一定是lock-free的。
       
            无等待结构：Read-Copy-Update.
            
            对数据的读可以不加控制。因此所有的读线程都是无等待。写数据的时候，先取得原始数据副本，
            接着修改副本数据，修改完后，等待合适的时机写回数据。
            
        
        1,2 是阻塞，3，4，5是非阻塞,无锁用的更多
    
    6、Amdahl 定律
        加速比＝优化前系统耗时 ／ 优化后系统耗时 
        
        S=1/(1-a+a/n)
        其中，a为并行计算部分所占比例，n为并行处理结点个数。
        
        程序中可并行代码的比例决定你增加处理器（总核心数）所能带来的速度提升的上限
    7、Gustafson 定律
      
#3、JMM原子性、可见性与有序性     
    #1、原子性（ Atomicity)
        原子性是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一
        旦开始，就不会被其他线程干扰。 
    #2、可见性（ Visibility)
        可见性是指当一个线程修改了某一个共享变量的值时，其他线程是否能够立即知道这个修改。
    #3、有序性（ odering)
        有序性问题的原因是程序在执行时，可能会进行指令重排，重排后的指令与原指令的顺序未必一致。
        
    #4、Happen-Before 规则
         程序顺序原则： 一个线程内保证语义的串行性 。
         
         volatile 规则： volatile 变量 的写先于读发生 ，这保证了 volatile 变量的可见性 。
         锁规则： 解锁（ unlock ）必然发生在随后的加锁（ lociο 前。
         传递性： A 先于 B, B 先于 C，那么 A 必然先于 C 。
         线程的 start（）方法先于它 的每一个动作 。
         线程 的所有操作先于线程 的 终结（ Thread.join() ）。
         线程的中断（interrupt）先于被中断线程的代码。 
