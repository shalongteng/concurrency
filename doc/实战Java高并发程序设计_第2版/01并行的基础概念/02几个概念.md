#1、并发 Concurrency 和并行 Parallelism
    并发
        井发偏重于多个任务交替执行，而多个任务之间有可能还是串行的，
    并行
        而并行是真正意义上的“同时执行”
#2、临界区
    临界区用来表示一种公共资源或者说共享数据 ，可以被多个线程使用每一次，只能有一个线程使用它，
    临界区资源被占用，其他线程要想使用这个资源就必须等待。
#3、阻塞和非阻塞
    阻塞
        一个线程占用了临界区界区资源，其他所有需要这个资源的线程就必须在这个临界区中等待 。
        等待会导致线程挂起，这种情况就是阻塞。
    非阻塞
        非阻塞与之相反
#4、死锁（ Deadlock）、饥饿（ Starvation ）和活锁（ Livelock)
    死锁
        每个进程都在等待被其他进程占用并堵塞了的资源。例如，如果进程A锁住了记录1并等待记录2，
        而进程B锁住了记录2并等待记录1，这样两个进程就发生了死锁现象。
    饥饿
        一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行。比如它的线程优先级可能太低，
        而高优先级的线程不断抢占它需要的资源，导致低优先级线程无法工作 。 
    活锁  （类似于算法不合理，死循环了）
        活锁应该是一系列进程在轮询地等待某个不可能为真的条件为真。活锁的时候进程是不会blocked，
        这会导致耗尽CPU资源
        
        单一实体的活锁
            线程从队列中拿出一个任务来执行，如果任务执行失败，那么将任务重新加入队列，继续执行。
            假设任务总是执行失败，或者某种依赖的条件总是不满足，那么线程一直在繁忙却没有任何结果。
        协同导致的活锁
            生活中的典型例子： 两个人在窄路相遇，同时向一个方向避让，然后又向另一个方向避让，如此反复。
            通信中也有类似的例子，多个用户共享信道（最简单的例子是大家都用对讲机），同一时刻只能有一方发送信息。
            发送信号的用户会进行冲突检测， 如果发生冲突，就选择避让，然后再发送。 假设避让算法不合理，
            就导致每次发送，都冲突，避让后再发送，还是冲突。
            
            计算机中的例子：两个线程发生了某些条件的碰撞后重新执行，那么如果再次尝试后依然发生了碰撞，
            长此下去就有可能发生活锁。
#5、并发的程度
    http://ifeve.com/why-is-wait-free-so-important/#more-10350
    
    阻塞调度是一种悲观策略
    非阻塞调度是一种乐观策略

    1、阻塞(Blocking)
        synchronized关键字，或者重入锁时就会产生阻塞的线程
    
    2、无饥饿(Starvation-Free)
        低优先级线程产生饥饿
    
    3、无障碍(Obstruction-Free)
        这是一种最弱的非阻塞调度。两个线程如果都是无障碍执行，临界区被占用时，不会被阻塞。
        如果发现数据异常，就会对之前的操作进行回滚，确保数据安全。如果没有发生数据竞争，则可以顺利经过临界区。
    
    4、无锁(Lock-Free)
        一个无锁算法有一个方法，这个方法需要同步。在单线程模式下这个方法调用需要10ns，
        每增加一个线程调用这个方法，将在同步(变量)上产生争用。如果只有一个线程，每次调用该方法到返回时间都为10ns，
        如果你增加更多的线程，他们将会增加其他线程执行完成的时间，这是因为同一时刻只有一个线程能获得锁；
        
        记住，无锁(Lock-Free)保证一个线程可以执行，但没说是哪一个，并且在当前这个特定的例子中，每次只有一个线程可以执行(完成任务)，其他线程不得不从头开始：
    
    5、无等待(Wait-Free)
        所谓wait-free是指，不管其他线程执行什么操作，线程无论有什么操作都能在有限的步骤里面完成。
        所以对于算法来说达到lock-free不一定能达到wait-free，但是达到wait-free的算法一定是lock-free的。
   

        无等待结构：Read-Copy-Update.
        
        对数据的读可以不加控制。因此所有的读线程都是无等待。写数据的时候，先取得原始数据副本，
        接着修改副本数据，修改完后，等待合适的时机写回数据。
        
    
    1,2 是阻塞，3，4，5是非阻塞,无锁用的更多



#6、Amdahl 定律
    加速比＝优化前系统耗时 ／ 优化后系统耗时 
    
    S=1/(1-a+a/n)
    其中，a为并行计算部分所占比例，n为并行处理结点个数。
    
    程序中可并行代码的比例决定你增加处理器（总核心数）所能带来的速度提升的上限
#7、Gustafson 定律
