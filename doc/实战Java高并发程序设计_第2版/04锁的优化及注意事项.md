#1、有助于提高锁性能的几点建议
    对于多线程应用来说，系统除了处理功能需求外 ，还 需要额外维护多线程环境的特有信息 ，如线程本
    身的元数据、线程的调度、线程上下文的切换等 。
    
    1、减少锁持有时间
        线程持有锁的时间越长 ， 那么 相对地， 锁的竞争程度也就越激烈
    1、减小锁粒度
        ConcurrentHashMap
            一个 ConcurrentHashMap 类可 以被细分为 16 个段。分段锁。
            试图访问 ConcurrentHashMap 类的全局信息时，就需要同时取得所有段的锁方能顺利实施。所以size方法比较耗时
    1、用读写分离锁来替换独占锁
        在读 多 写少的场合使用 读写锁可以有效提升 系统的并发能力 。
    1、锁分离
        LinkedB lockingQueue
            takeLock
            putLock
    1、锁粗化
        在循环内请求锁时 。将锁放到循环外，只加一次锁即可。
#2、JVM对锁的优化
    1、锁偏向
        当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，
        表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。
        出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。
        
        偏向锁升级
            偏向锁 轻量级锁（自旋锁） 重量级锁
            锁可以升级不可以降级，但是偏向锁状态可以被重置为无锁状态。
    1、轻量级锁
        虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，存储锁对象目前的Mark Word的拷贝
        然后，虚拟机将使用CAS操作尝试把对象的Mark Word更新为指向Lock Record的指针。
    1、锁消除
        锁消除涉及的一项关键技术为逃逸分析 
#3、ThreadLocal
    一个线程的局部变量
    1、Threadlocal 的实现原理

#4、无锁
    1、CAS
        CAS(V,E,N）
    1、Atomiclnteger
    1、Unsafe 类
    1、AtomicReference
        ABA问题
    6、AtomicStampedReference
        它内部不仅维护了对象值，还维护了一个时间戳
    6、AtomiclntegerArray
    6、SynchronousQueue 的实现
        SynchronousQueue是一个内部只能包含一个元素的队列。插入元素到队列的线程被阻塞，直到另一个线程从队列中
        获取了队列中存储的元素。同样，如果线程尝试获取元素并且当前不存在任何元素，则该线程将被阻塞，直到线程将
        元素插入队列。
        
#5、死锁
    
