#1、Java语言中的线程安全
    按照线程安全的“安全程度”由强至弱来排序，我们可以将Java语言中各种操作【共享的数据】分为以下五类：
        
        不可变 （Immutable）
            不可变的对象一定线程安全
            
            final修饰的基本类型
            引用类型，需要自己维护
                string类，包装类（Integer），枚举类型
                把对象里状态变量声明为final
        绝对线程安全
            两个线程一个线程对vector删除，一个读取，也会线程不安全，也就是无法做到绝对的线程安全。
            
            假如Vector一定要做到绝对的线程安全，那就必须在它内部维护一组一致性的快照访问才行，每次
            对其中元素进行改动都要产生新的快照。
        相对线程安全
            相对线程安全就是我们通常意义上所讲的线程安全，它需要保证对这个对象【单次】的操作是线程安
            全的，我们在调用的时候不需要进行额外的保障措施，但是对于一些特定顺序的连续调用，就可能需
            要在调用端使用额外的同步手段来保证调用的正确性。
            
            在Java语言中，大部分声称线程安全的类都属于这种类型，
        线程兼容
            线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对
            象在并发环境中可以安全地使用。比如类ArrayList和HashMap等
        线程对立
            不管调用端是否采取了同步措施，都无法在多线程环境中并发使用代码
    
#2、线程安全的实现方法
    虚拟机如何实现同步与锁
    1.互斥同步
        同步是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一条（或者是一些，
        当使用信号量的时候）线程使用。
        
        而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量
        （Mutex）和信号量（Semaphore）都是常见的互斥实现方式。因此在“互斥同步”这四个字里面，互斥
        是因，同步是果；互斥是方法，同步是目的。
        
        synchronized关键字经过Javac编译之后，会在同步块的前后分别形成
            monitorenter
            monitorexit这两个字节码指令
        
        执行monitorenter指令时，要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁
        就把锁的计数器的值增加一，而在执行monitorexit指令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。
            可重入
            无法强制已获取锁的线程释放锁；也无法强制正在等待锁的线程中断等待或超时退出。
            
        从执行成本的角度看，持有锁是一个重量级（Heavy-Weight）的操作，Java的线程是映射到操作系统的原生内核线程之上的，
        如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转
        换需要耗费很多的处理器时间。
        
        而虚拟机本身也会进行一些优化，譬如在通知操作系统【阻塞线程之前】加入一段自旋等待过程，以避免频繁地切入核心态之中。
        
        ReentrantLock与synchronized相比增加了一些高级功能
            等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，
            公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；
            
            锁绑定多个条件：ReentrantLock对象可以同时绑定多个Condition对象。在synchronized
            中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一
            个的条件关联的时候，就不得不额外添加一个锁；ReentrantLock多次调用newCondition()方法即可
            
        2.非阻塞同步
            随着硬件指令集的发展，基于冲突检测的乐观并发策略，就是不管风险，先进行操作，如果没有其他线程
            争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，
            最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程
            阻塞挂起，因此这种同步操作被称为非阻塞同步（Non-Blocking Synchronization），
            
            为什么使用乐观并发策略需要“硬件指令集的发展”？
                必须要求【操作】和【冲突检测】这两个步骤具备原子性。靠什么来保证原子性？靠硬件来实现这件事情，
                硬件保证某些从语义上看起来需要多次操作的行为可以只通过一条处理器指令就能完成，
                这类指令常用的有：
                    ·测试并设置（Test-and-Set）；
                    ·获取并增加（Fetch-and-Increment）；
                    ·交换（Swap）；
                    ·比较并交换（Compare-and-Swap，下文称CAS）；
                    ·加载链接/条件储存（Load-Linked/Store-Conditional，下文称LL/SC）
                
                CAS指令需要有三个操作数，
                    内存位置（用V表示）
                    旧的预期值（用A表示）
                    准备设置的新值（用B表示）
                    
                ABA问题
                    如果一个变量V初次读取的时候是A值，在准备赋值的时候检查到它仍然为A值，能说明它的值没有被其他线程改变过了吗？
                    是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。
        3.无同步方案
            如果一个方法本来就不涉及共享数据，那它自然就不需要任何同步措施去保证其正确性，
            因此会有一些代码天生就是线程安全的，简单介绍其中的两类
                可重入代码（Reentrant Code）：
                线程本地存储（Thread Local Storage）：ThreadLocal类
                
                
#3、