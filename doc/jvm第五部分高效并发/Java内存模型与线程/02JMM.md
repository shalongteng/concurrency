#1、Java内存模型 （Java Memory Model， JMM）
    JMM屏蔽各种硬件和操作系统的内存访问差异，实现让Java程序在各种平台下都能达到一致的内存访问效果。
    主流程序语言（如C和C++等）直接使用物理硬件和操作系统的内存模型。
    
#2、主内存与工作内存
    主内存（Main Memory）中
        主内存与介绍物理硬件时提到的主内存名字一样，两者可以类比。
        Java内存模型规定了所有的变量都存储在此处
       
    工作内存（Working Memory，
        可与前面讲的处理器高速缓存类比，
        线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内
        存中进行，而不能直接读写主内存中的数据[3]。
        
        不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，
        
    主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机（或者是硬件、操作系统本身的优化措施）可能会让工作内存优先存储
    于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存
#3、内存间交互操作
    主内存与工作内存之间的交互协议，(一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存)
    Java内存模型中定义了以下8种操作来完成。 Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的
    （对于double和long类型的变量来说，load、 store、 read和write操作在某些平台上允许有例外，这个问题在12.3.4节会专门讨论）
    
    ·lock（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。
    ·unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
    ·read（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
    
    ·load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的 变量副本中。
    ·use（使用）：作用于工作内存的变量，把工作内存中变量的值传递给执行引擎，当JVM遇到使用变量的值的字节码指令时将会执行这个操作。
    ·assign（赋值）：作用于工作内存的变量，把从执行引擎接收的值赋给工作内存的变量，当JVM遇到给变量赋值的字节码指令时执行这个操作。
    ·store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
    ·write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。
    

    成对出现
        read load
        store write 
#4、对于volatile型变量的特殊规则
    关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制
    
    保证此变量对所有线程的可见性
    禁止指令重排
        volatile修饰的变量，赋值后（前面mov%eax， 0x150(%esi)这句便是赋值操作）多执行了一个“lock addl$0x0， (%esp)”操作，
        这个操作的作用相当于一个内存屏障（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置，
        
        这句指令中的“addl$0x0， (%esp)”（把ESP寄存器的值加0）显然是一个空操作,它的作用是将本处理器的缓存写入了内存，
        该写入动作也会引起 别的处理器或者别的内核无效化（Invalidate）其缓存
#5、针对long和double型变量的特殊规则
    对于64位的数据类型（long和double）：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，
    即允许虚拟机实现自行选择是否要保证64位数据类型的load、 store、 read和write这四个操作的原子性，
    这就是所谓的“long和double的非原子性协定”（Non-Atomic Treatment of double and long Variables）。
    
    对于32位的Java虚拟机，譬如比较常用的32位x86平台下的HotSpot虚拟机，对long类型的数据确实存在非原子性访问的风险
#6、原子性、可见性与有序性
    1.原子性（Atomicity）
        由Java内存模型来直接保证的原子性变量操作包括read、 load、 assign、 use、 store和write这六个，
        基本数据类型的访问、读写都是具备原子性的（例外就是long和double的非原子性协定)
        synchronized块之间的操作也具备原子性。
    2.可见性（Visibility）
        Java内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的
        Java还有两个关键字能实现可见性，它们是synchronized和final。
    3.有序性（Ordering）
        如果在本线程内观察，所有的操作都是有序的；
            线程内似表现为串行的语义”（Within-Thread As-If-SerialSemantics），
        如果在一个线程中观察另一个线程，所有的操作都是无序的。
            “指令重排序”现象和“工作内存与主内存同步延迟”
            
        Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性
#7、先行发生原则（Happens-Before）
    先行发生是Java内存模型中定义的两项操作之间的偏序关系，比如说操作A先行发生于操作B，其实就是说在发生操作B之前，
    操作A产生的影响能被操作B观察到，
    
    下面是Java内存模型下一些“天然的“先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用。
    如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，则它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。 
        ·程序次序规则（Program Order Rule）：
        ·管程锁定规则（Monitor Lock Rule）：
        ·volatile变量规则（Volatile Variable Rule）：
        ·线程启动规则（Thread Start Rule）：
        ·线程终止规则（Thread Termination Rule）：
        ·线程中断规则（Thread Interruption Rule）：
        ·对象终结规则（Finalizer Rule）：
        ·传递性（Transitivity）：
