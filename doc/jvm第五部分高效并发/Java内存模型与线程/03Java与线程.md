#1、线程的实现
    线程可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），
    又可以独立调度。
    
    内核线程实现
        使用内核线程实现的方式也被称为1： 1实现。内核线程（Kernel-Level Thread， KLT）就是直接由操作系统内核支持的线程，
        这种线程由内核来完成线程切换，内核通过操纵调度器（Scheduler）对线程进行调度，并负责将线程的任务映射到各个处理器上。
        
        局限性：
            各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，
            需要在用户态（User Mode）和内核态（Kernel Mode）中来回切换。
    用户线程实现
        使用用户线程实现的方式被称为1： N实现。
        多个用户线程映射一个进程，分配cpu。
        
        系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，
    混合实现
        还有一种将内核线程与用户线程一起使用的实现方式，被称为N： M实现。
    Java线程的实现
        Java线程如何实现并不受Java虚拟机规范的约束，这是一个与具体虚拟机相关的话题。
        
        以HotSpot为例，它的每一个Java线程都是直接映射到一个操作系统原生线程来实现的，
#2、Java线程调度
    协同式（Cooperative Threads-Scheduling）线程调度
        好处是实现简单
        坏处也很明显：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，
        那么程序就会一直阻塞在那里。
    抢占式（Preemptive Threads-Scheduling）线程调度
        每个线程将由系统来分配执行时间
#3、状态转换
    Java语言定义了6种线程状态，
        新建（New）：创建后尚未启动的线程处于这种状态
        运行（Runnable）：包括操作系统线程状态中的Running和Ready，处于此状态的线程有可能正在执行，也可能正在等待着操作系统为它分配执行时间。
        无限期等待（Waiting）：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：
            ■没有设置Timeout参数的Object::wait()方法；
            ■没有设置Timeout参数的Thread::join()方法；
            ■LockSupport::park()方法。
        限期等待（Timed Waiting）：这种状态的线程也不会被分配处理器执行时间，无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。
            ■Thread::sleep()方法；
            ■设置了Timeout参数的Object::wait()方法；
            ■设置了Timeout参数的Thread::join()方法；
            ■LockSupport::parkNanos()方法；
            ■LockSupport::parkUntil()方法。
        阻塞（Blocked）：线程被阻塞了， 
            “阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；
            而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。
        结束（Terminated）：已终止线程的线程状态，线程已经结束执行
#4、Java线程调度
