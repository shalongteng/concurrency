#1、synchronized实现
    JDK早期的 重量级 - OS操作系统
    
    sync (Object) 锁升级
        markword 记录这个线程ID （偏向锁）
        如果有线程争用：升级为 自旋锁（10次以后）
        升级为重量级锁 - OS
        
        https://www.jianshu.com/p/b43b7bf5e052
    
        执行时间短（加锁代码），线程数少，用自旋，自旋锁占用CPU时间。
        执行时间长，线程数多，用系统锁，synchronized会进入等待队列，不占用CPU时间。
#2、锁优化
    锁的细化
    
#3、synchronized异常锁
    程序执行过程中，如果发生异常，默认锁会被释放。
#4、CAS无锁优化（自旋）
    compare and set
    cas(V,Expected,New)
    if(V==Expected)
        V==New
    else
        try again
    cas原语
    
    atomicInteger
#5、CAS的ABA问题
    加版本号  version
    如果 基础类型 没影响
    如果引用类型 会出问题
    
    
#6、Unsafe
    
    compareAndSwapInt
    直接操作对象内存地址（c++）
    allocateMemory 申请内存 c malloc free
    freeMemory
#6、volatile
    靠 MESI 缓存一致性协议 来实现java的线程缓存一致性。
    保证线程可见性
    
    进制指令重排序
    指令流水
    
    
    马士兵-Java高级工程师就业班-2多线程与高并发（一）- 线程状态
    马士兵-Java高级工程师就业班-3多线程与高并发（二）- volatile禁止指令重排序
    马士兵-Java高级工程师就业班-4多线程与高并发（三）- CAS新类型锁-ReentrantLock